{"ast":null,"code":"// TODO(v3): Convert to sync.\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign(_ref) {\n  let {\n    hash,\n    privateKey,\n    to = 'object'\n  } = _ref;\n  const {\n    r,\n    s,\n    recovery\n  } = secp256k1.sign(hash.slice(2), privateKey.slice(2));\n  const signature = {\n    r: numberToHex(r, {\n      size: 32\n    }),\n    s: numberToHex(s, {\n      size: 32\n    }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery\n  };\n  return (() => {\n    if (to === 'bytes' || to === 'hex') return serializeSignature({\n      ...signature,\n      to\n    });\n    return signature;\n  })();\n}","map":{"version":3,"names":["secp256k1","numberToHex","serializeSignature","sign","_ref","hash","privateKey","to","r","s","recovery","slice","signature","size","v","yParity"],"sources":["/Users/emmanasseri/Desktop/my-own-words/client/node_modules/viem/accounts/utils/sign.ts"],"sourcesContent":["// TODO(v3): Convert to sync.\n\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignParameters<to extends To = 'object'> = {\n  hash: Hex\n  privateKey: Hex\n  to?: to | To | undefined\n}\n\nexport type SignReturnType<to extends To = 'object'> =\n  | (to extends 'object' ? Signature : never)\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type SignErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign<to extends To = 'object'>({\n  hash,\n  privateKey,\n  to = 'object',\n}: SignParameters<to>): Promise<SignReturnType<to>> {\n  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2))\n  const signature = {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  }\n  return (() => {\n    if (to === 'bytes' || to === 'hex')\n      return serializeSignature({ ...signature, to })\n    return signature\n  })() as SignReturnType<to>\n}\n"],"mappings":"AAAA;AAEA,SAASA,SAAS,QAAQ,yBAAyB;AAInD,SAEEC,WAAW,QACN,+BAA+B;AACtC,SAASC,kBAAkB,QAAQ,6CAA6C;AAiBhF;;;;;;;;AAQA,OAAO,eAAeC,IAAIA,CAAAC,IAAA,EAIL;EAAA,IAJgC;IACnDC,IAAI;IACJC,UAAU;IACVC,EAAE,GAAG;EAAQ,CACM,GAAAH,IAAA;EACnB,MAAM;IAAEI,CAAC;IAAEC,CAAC;IAAEC;EAAQ,CAAE,GAAGV,SAAS,CAACG,IAAI,CAACE,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC,EAAEL,UAAU,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7E,MAAMC,SAAS,GAAG;IAChBJ,CAAC,EAAEP,WAAW,CAACO,CAAC,EAAE;MAAEK,IAAI,EAAE;IAAE,CAAE,CAAC;IAC/BJ,CAAC,EAAER,WAAW,CAACQ,CAAC,EAAE;MAAEI,IAAI,EAAE;IAAE,CAAE,CAAC;IAC/BC,CAAC,EAAEJ,QAAQ,GAAG,GAAG,GAAG,GAAG;IACvBK,OAAO,EAAEL;GACV;EACD,OAAO,CAAC,MAAK;IACX,IAAIH,EAAE,KAAK,OAAO,IAAIA,EAAE,KAAK,KAAK,EAChC,OAAOL,kBAAkB,CAAC;MAAE,GAAGU,SAAS;MAAEL;IAAE,CAAE,CAAC;IACjD,OAAOK,SAAS;EAClB,CAAC,EAAC,CAAwB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
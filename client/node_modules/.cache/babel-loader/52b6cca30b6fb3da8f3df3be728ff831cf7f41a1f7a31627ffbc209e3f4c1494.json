{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError } from '../../errors/abi.js';\nimport { checksumAddress } from '../address/getAddress.js';\nimport { createCursor } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { sliceBytes } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { bytesToBigInt, bytesToBool, bytesToNumber, bytesToString } from '../encoding/fromBytes.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data;\n  const cursor = createCursor(bytes);\n  if (size(bytes) === 0 && params.length > 0) throw new AbiDecodingZeroDataError();\n  if (size(data) && size(data) < 32) throw new AbiDecodingDataSizeTooSmallError({\n    data: typeof data === 'string' ? data : bytesToHex(data),\n    params: params,\n    size: size(data)\n  });\n  let consumed = 0;\n  const values = [];\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i];\n    cursor.setPosition(consumed);\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0\n    });\n    consumed += consumed_;\n    values.push(data);\n  }\n  return values;\n}\nfunction decodeParameter(cursor, param, _ref) {\n  let {\n    staticPosition\n  } = _ref;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor);\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\n////////////////////////////////////////////////////////////////////\n// Type Decoders\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor) {\n  const value = cursor.readBytes(32);\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, _ref2) {\n  let {\n    length,\n    staticPosition\n  } = _ref2;\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\nfunction decodeBool(cursor) {\n  return [bytesToBool(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\nfunction decodeBytes(cursor, param, _ref3) {\n  let {\n    staticPosition\n  } = _ref3;\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = bytesToNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [bytesToHex(data), 32];\n  }\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? bytesToBigInt(value, {\n    signed\n  }) : bytesToNumber(value, {\n    signed\n  }), 32];\n}\nfunction decodeTuple(cursor, param, _ref4) {\n  let {\n    staticPosition\n  } = _ref4;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(_ref5 => {\n    let {\n      name\n    } = _ref5;\n    return !name;\n  });\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\nfunction decodeString(cursor, _ref6) {\n  let {\n    staticPosition\n  } = _ref6;\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = bytesToNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = bytesToString(trim(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiDecodingZeroDataError","InvalidAbiDecodingTypeError","checksumAddress","createCursor","size","sliceBytes","trim","bytesToBigInt","bytesToBool","bytesToNumber","bytesToString","hexToBytes","bytesToHex","getArrayComponents","decodeAbiParameters","params","data","bytes","cursor","length","consumed","values","i","param","setPosition","consumed_","decodeParameter","staticPosition","push","_ref","arrayComponents","type","decodeArray","decodeTuple","decodeAddress","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","docsPath","sizeOfLength","sizeOfOffset","value","readBytes","_ref2","offset","start","startOfData","dynamicChild","hasDynamicChild","_ref3","_","split","Number","parseInt","signed","_ref4","hasUnnamedChild","components","some","_ref5","name","component","_ref6","endsWith"],"sources":["/Users/emmanasseri/Desktop/my-own-words/client/node_modules/viem/utils/abi/decodeAbiParameters.ts"],"sourcesContent":["import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
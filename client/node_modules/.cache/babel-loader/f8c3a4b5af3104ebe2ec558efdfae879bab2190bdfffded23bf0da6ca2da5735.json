{"ast":null,"code":"import { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { formatLog } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs(client) {\n  let {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    events: events_,\n    args,\n    strict: strict_\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const strict = strict_ ?? false;\n  const events = events_ ?? (event ? [event] : undefined);\n  let topics = [];\n  if (events) {\n    const encoded = events.flatMap(event => encodeEventTopics({\n      abi: [event],\n      eventName: event.name,\n      args: events_ ? undefined : args\n    }));\n    // TODO: Clean up type casting\n    topics = [encoded];\n    if (event) topics = topics[0];\n  }\n  let logs;\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{\n        address,\n        topics,\n        blockHash\n      }]\n    });\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{\n        address,\n        topics,\n        fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock\n      }]\n    });\n  }\n  const formattedLogs = logs.map(log => formatLog(log));\n  if (!events) return formattedLogs;\n  return parseEventLogs({\n    abi: events,\n    args: args,\n    logs: formattedLogs,\n    strict\n  });\n}","map":{"version":3,"names":["encodeEventTopics","parseEventLogs","numberToHex","formatLog","getLogs","client","address","blockHash","fromBlock","toBlock","event","events","events_","args","strict","strict_","arguments","length","undefined","topics","encoded","flatMap","abi","eventName","name","logs","request","method","params","formattedLogs","map","log"],"sources":["/Users/emmanasseri/Desktop/my-own-words/node_modules/viem/actions/public/getLogs.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetLogsParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[] | undefined\n} & (\n  | {\n      event: abiEvent\n      events?: undefined\n      args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events: abiEvents\n      args?: undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events?: undefined\n      args?: undefined\n      strict?: undefined\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n        /** Block number or tag before which to include logs */\n        toBlock?: toBlock | BlockNumber | BlockTag | undefined\n        blockHash?: undefined\n      }\n    | {\n        fromBlock?: undefined\n        toBlock?: undefined\n        /** Hash of block to include logs from */\n        blockHash?: Hash | undefined\n      }\n  )\n\nexport type GetLogsReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _pending, abiEvent, strict, abiEvents, _eventName>[]\n\nexport type GetLogsErrorType =\n  | DecodeEventLogErrorType\n  | EncodeEventTopicsErrorType\n  | FormatLogErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    events: events_,\n    args,\n    strict: strict_,\n  }: GetLogsParameters<abiEvent, abiEvents, strict, fromBlock, toBlock> = {},\n): Promise<GetLogsReturnType<abiEvent, abiEvents, strict, fromBlock, toBlock>> {\n  const strict = strict_ ?? false\n  const events = events_ ?? (event ? [event] : undefined)\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args: events_ ? undefined : args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n\n  const formattedLogs = logs.map((log) => formatLog(log))\n  if (!events)\n    return formattedLogs as GetLogsReturnType<\n      abiEvent,\n      abiEvents,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: events,\n    args: args as any,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetLogsReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n"],"mappings":"AAeA,SAGEA,iBAAiB,QACZ,sCAAsC;AAC7C,SAASC,cAAc,QAAQ,mCAAmC;AAElE,SAEEC,WAAW,QACN,+BAA+B;AACtC,SAEEC,SAAS,QACJ,+BAA+B;AAoFtC;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,eAAeC,OAAOA,CAW3BC,MAAgC,EAU0C;EAAA,IAT1E;IACEC,OAAO;IACPC,SAAS;IACTC,SAAS;IACTC,OAAO;IACPC,KAAK;IACLC,MAAM,EAAEC,OAAO;IACfC,IAAI;IACJC,MAAM,EAAEC;EAAO,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MACuD,EAAE;EAE1E,MAAMF,MAAM,GAAGC,OAAO,IAAI,KAAK;EAC/B,MAAMJ,MAAM,GAAGC,OAAO,KAAKF,KAAK,GAAG,CAACA,KAAK,CAAC,GAAGQ,SAAS,CAAC;EAEvD,IAAIC,MAAM,GAAe,EAAE;EAC3B,IAAIR,MAAM,EAAE;IACV,MAAMS,OAAO,GAAIT,MAAqB,CAACU,OAAO,CAAEX,KAAK,IACnDV,iBAAiB,CAAC;MAChBsB,GAAG,EAAE,CAACZ,KAAK,CAAC;MACZa,SAAS,EAAGb,KAAkB,CAACc,IAAI;MACnCX,IAAI,EAAED,OAAO,GAAGM,SAAS,GAAGL;KACE,CAAC,CAClC;IACD;IACAM,MAAM,GAAG,CAACC,OAAmB,CAAC;IAC9B,IAAIV,KAAK,EAAES,MAAM,GAAGA,MAAM,CAAC,CAAC,CAAe;EAC7C;EAEA,IAAIM,IAAc;EAClB,IAAIlB,SAAS,EAAE;IACbkB,IAAI,GAAG,MAAMpB,MAAM,CAACqB,OAAO,CAAC;MAC1BC,MAAM,EAAE,aAAa;MACrBC,MAAM,EAAE,CAAC;QAAEtB,OAAO;QAAEa,MAAM;QAAEZ;MAAS,CAAE;KACxC,CAAC;EACJ,CAAC,MAAM;IACLkB,IAAI,GAAG,MAAMpB,MAAM,CAACqB,OAAO,CAAC;MAC1BC,MAAM,EAAE,aAAa;MACrBC,MAAM,EAAE,CACN;QACEtB,OAAO;QACPa,MAAM;QACNX,SAAS,EACP,OAAOA,SAAS,KAAK,QAAQ,GAAGN,WAAW,CAACM,SAAS,CAAC,GAAGA,SAAS;QACpEC,OAAO,EAAE,OAAOA,OAAO,KAAK,QAAQ,GAAGP,WAAW,CAACO,OAAO,CAAC,GAAGA;OAC/D;KAEJ,CAAC;EACJ;EAEA,MAAMoB,aAAa,GAAGJ,IAAI,CAACK,GAAG,CAAEC,GAAG,IAAK5B,SAAS,CAAC4B,GAAG,CAAC,CAAC;EACvD,IAAI,CAACpB,MAAM,EACT,OAAOkB,aAMN;EACH,OAAO5B,cAAc,CAAC;IACpBqB,GAAG,EAAEX,MAAM;IACXE,IAAI,EAAEA,IAAW;IACjBY,IAAI,EAAEI,aAAa;IACnBf;GACD,CAMA;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
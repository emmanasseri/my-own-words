{"ast":null,"code":"import { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter(client) {\n  let {\n    address,\n    args,\n    event,\n    events: events_,\n    fromBlock,\n    strict,\n    toBlock\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const events = events_ ?? (event ? [event] : undefined);\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter'\n  });\n  let topics = [];\n  if (events) {\n    const encoded = events.flatMap(event => encodeEventTopics({\n      abi: [event],\n      eventName: event.name,\n      args\n    }));\n    // TODO: Clean up type casting\n    topics = [encoded];\n    if (event) topics = topics[0];\n  }\n  const id = await client.request({\n    method: 'eth_newFilter',\n    params: [{\n      address,\n      fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n      toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n      ...(topics.length ? {\n        topics\n      } : {})\n    }]\n  });\n  return {\n    abi: events,\n    args,\n    eventName: event ? event.name : undefined,\n    fromBlock,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    toBlock,\n    type: 'event'\n  };\n}","map":{"version":3,"names":["encodeEventTopics","numberToHex","createFilterRequestScope","createEventFilter","client","address","args","event","events","events_","fromBlock","strict","toBlock","arguments","length","undefined","getRequest","method","topics","encoded","flatMap","abi","eventName","name","id","request","params","Boolean","type"],"sources":["/Users/emmanasseri/Desktop/my-own-words/client/node_modules/viem/actions/public/createEventFilter.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex, LogTopic } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateEventFilterParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[] | undefined\n  fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n  toBlock?: toBlock | BlockNumber | BlockTag | undefined\n} & (MaybeExtractEventArgsFromAbi<\n  abiEvents,\n  _eventName\n> extends infer eventFilterArgs\n  ?\n      | {\n          args:\n            | eventFilterArgs\n            | (_args extends eventFilterArgs ? _args : never)\n          event: abiEvent\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: abiEvent | undefined\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events: abiEvents | undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events?: undefined\n          strict?: undefined\n        }\n  : {\n      args?: undefined\n      event?: undefined\n      events?: undefined\n      strict?: undefined\n    })\n\nexport type CreateEventFilterReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = Prettify<\n  Filter<'event', abiEvents, _eventName, _args, strict, fromBlock, toBlock>\n>\n\nexport type CreateEventFilterErrorType =\n  | EncodeEventTopicsErrorType\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    args,\n    event,\n    events: events_,\n    fromBlock,\n    strict,\n    toBlock,\n  }: CreateEventFilterParameters<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  > = {} as any,\n): Promise<\n  CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n> {\n  const events = events_ ?? (event ? [event] : undefined)\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        ...(topics.length ? { topics } : {}),\n      },\n    ],\n  })\n\n  return {\n    abi: events,\n    args,\n    eventName: event ? (event as AbiEvent).name : undefined,\n    fromBlock,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    toBlock,\n    type: 'event',\n  } as unknown as CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n}\n"],"mappings":"AAcA,SAGEA,iBAAiB,QACZ,sCAAsC;AAE7C,SAEEC,WAAW,QACN,+BAA+B;AACtC,SAASC,wBAAwB,QAAQ,iDAAiD;AA6F1F;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAO,eAAeC,iBAAiBA,CAerCC,MAAgC,EAiBnB;EAAA,IAhBb;IACEC,OAAO;IACPC,IAAI;IACJC,KAAK;IACLC,MAAM,EAAEC,OAAO;IACfC,SAAS;IACTC,MAAM;IACNC;EAAO,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MASL,EAAS;EAYb,MAAML,MAAM,GAAGC,OAAO,KAAKF,KAAK,GAAG,CAACA,KAAK,CAAC,GAAGQ,SAAS,CAAC;EAEvD,MAAMC,UAAU,GAAGd,wBAAwB,CAACE,MAAM,EAAE;IAClDa,MAAM,EAAE;GACT,CAAC;EAEF,IAAIC,MAAM,GAAe,EAAE;EAC3B,IAAIV,MAAM,EAAE;IACV,MAAMW,OAAO,GAAIX,MAAqB,CAACY,OAAO,CAAEb,KAAK,IACnDP,iBAAiB,CAAC;MAChBqB,GAAG,EAAE,CAACd,KAAK,CAAC;MACZe,SAAS,EAAGf,KAAkB,CAACgB,IAAI;MACnCjB;KAC8B,CAAC,CAClC;IACD;IACAY,MAAM,GAAG,CAACC,OAAmB,CAAC;IAC9B,IAAIZ,KAAK,EAAEW,MAAM,GAAGA,MAAM,CAAC,CAAC,CAAe;EAC7C;EAEA,MAAMM,EAAE,GAAQ,MAAMpB,MAAM,CAACqB,OAAO,CAAC;IACnCR,MAAM,EAAE,eAAe;IACvBS,MAAM,EAAE,CACN;MACErB,OAAO;MACPK,SAAS,EACP,OAAOA,SAAS,KAAK,QAAQ,GAAGT,WAAW,CAACS,SAAS,CAAC,GAAGA,SAAS;MACpEE,OAAO,EAAE,OAAOA,OAAO,KAAK,QAAQ,GAAGX,WAAW,CAACW,OAAO,CAAC,GAAGA,OAAO;MACrE,IAAIM,MAAM,CAACJ,MAAM,GAAG;QAAEI;MAAM,CAAE,GAAG,EAAE;KACpC;GAEJ,CAAC;EAEF,OAAO;IACLG,GAAG,EAAEb,MAAM;IACXF,IAAI;IACJgB,SAAS,EAAEf,KAAK,GAAIA,KAAkB,CAACgB,IAAI,GAAGR,SAAS;IACvDL,SAAS;IACTc,EAAE;IACFC,OAAO,EAAET,UAAU,CAACQ,EAAE,CAAC;IACvBb,MAAM,EAAEgB,OAAO,CAAChB,MAAM,CAAC;IACvBC,OAAO;IACPgB,IAAI,EAAE;GASP;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
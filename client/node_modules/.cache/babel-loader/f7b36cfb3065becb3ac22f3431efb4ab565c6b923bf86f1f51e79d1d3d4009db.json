{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { createCursor } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function toRlp(bytes) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  const encodable = getEncodable(bytes);\n  const cursor = createCursor(new Uint8Array(encodable.length));\n  encodable.encode(cursor);\n  if (to === 'hex') return bytesToHex(cursor.bytes);\n  return cursor.bytes;\n}\nexport function bytesToRlp(bytes) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n  return toRlp(bytes, to);\n}\nexport function hexToRlp(hex) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  return toRlp(hex, to);\n}\nfunction getEncodable(bytes) {\n  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));\n  return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n  const sizeOfBodyLength = getSizeOfLength(bodyLength);\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength;\n    return 1 + sizeOfBodyLength + bodyLength;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength);\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);\n      }\n      for (const {\n        encode\n      } of list) {\n        encode(cursor);\n      }\n    }\n  };\n}\nfunction getEncodableBytes(bytesOrHex) {\n  const bytes = typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex;\n  const sizeOfBytesLength = getSizeOfLength(bytes.length);\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n    if (bytes.length <= 55) return 1 + bytes.length;\n    return 1 + sizeOfBytesLength + bytes.length;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes);\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length);\n        cursor.pushBytes(bytes);\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);\n        cursor.pushBytes(bytes);\n      }\n    }\n  };\n}\nfunction getSizeOfLength(length) {\n  if (length < 2 ** 8) return 1;\n  if (length < 2 ** 16) return 2;\n  if (length < 2 ** 24) return 3;\n  if (length < 2 ** 32) return 4;\n  throw new BaseError('Length is too large.');\n}","map":{"version":3,"names":["BaseError","createCursor","hexToBytes","bytesToHex","toRlp","bytes","to","arguments","length","undefined","encodable","getEncodable","cursor","Uint8Array","encode","bytesToRlp","hexToRlp","hex","Array","isArray","getEncodableList","map","x","getEncodableBytes","list","bodyLength","reduce","acc","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","bytesOrHex","sizeOfBytesLength","pushBytes"],"sources":["/Users/emmanasseri/Desktop/my-own-words/client/node_modules/viem/utils/encoding/toRlp.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}